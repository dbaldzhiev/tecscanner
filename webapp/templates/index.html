<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Remote Mandeye Controller for HDMapping</title>
    <style>
      :root {
        --primary: #007bff;
        --danger: #dc3545;
        --success: #28a745;
        --bg: #f4f4f4;
      }
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        background: var(--bg);
      }
      .container {
        max-width: 480px;
        margin: 0 auto;
        padding: 1rem;
      }
      h1 {
        text-align: center;
        font-size: 1.5rem;
        margin-bottom: 1rem;
      }
      #messages {
        text-align: center;
        margin-bottom: 1rem;
        min-height: 1.2rem;
      }
      .status-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: .5rem;
        margin-bottom: 1rem;
      }
      .status-grid p {
        margin: 0;
        padding: .5rem;
        background: #fff;
        border-radius: 4px;
        font-size: 0.9rem;
      }
      .status-grid progress {
        width: 100%;
        height: 8px;
        display: block;
        margin-top: .25rem;
      }
      #actions {
        display: flex;
        justify-content: space-between;
        margin-bottom: 1rem;
      }
      button {
        flex: 1;
        padding: 0.75rem;
        font-size: 1rem;
        border: none;
        border-radius: 4px;
        color: #fff;
      }
      button + button {
        margin-left: .5rem;
      }
      #start_btn {
        background: var(--primary);
      }
      #stop_btn {
        background: var(--danger);
      }
      button:disabled {
        background: #ccc;
        color: #666;
        cursor: not-allowed;
        opacity: .6;
      }
      ul {
        padding-left: 1rem;
      }
      #sysbar {
        display:flex;
        flex-wrap:wrap;
        justify-content:center;
        background:#eee;
        gap:.25rem;
        font-size:.75rem;
        padding:.25rem;
      }
      #sysbar span {
        padding:0 .25rem;
        border-radius:3px;
      }
      .ok { background: var(--success); color:#fff; }
      .bad { background: var(--danger); color:#fff; }
      .warn { background: #ffc107; color:#000; }
      @media (min-width: 600px) {
        .container { max-width: 700px; }
        .status-grid { grid-template-columns: repeat(2, 1fr); }
        button { flex: none; padding: 0.75rem 1.5rem; }
      }
    </style>
  </head>
  <body>
    <div id="sysbar">
      <span id="eth0_ip" class="{{ 'ok' if status.eth0_ip else 'bad' }}">{{ status.eth0_ip or 'eth0 ?' }}</span>
      <span id="lidar_ip" class="{{ 'ok' if status.lidar_detected else 'bad' }}">{{ status.lidar_ip or 'lidar ?' }}</span>
      <span id="livox_driver" class="{{ 'ok' if status.livox_driver else 'bad' }}">driver</span>
      <span id="save_laz" class="{{ 'ok' if status.save_laz else 'bad' }}">save_laz</span>
      <span id="laszip" class="{{ 'ok' if status.laszip else 'bad' }}">laszip</span>
      <span id="flash" class="{{ 'ok' if status.storage_present else 'bad' }}">storage</span>
      <span id="free_space" class="{{ 'ok' if status.free_space else 'bad' }}">
        {% if status.free_space %}{{ (status.free_space/(1024*1024))|round(1) }} MB{% else %}?{% endif %}
      </span>
    </div>
    <main class="container">
      <h1>Remote Mandeye Controller for HDMapping</h1>
      <div id="messages" role="status" aria-live="polite"></div>
      <div id="polling_control" style="text-align:center;margin-bottom:1rem;">
        <label><input type="checkbox" id="polling_toggle" {% if polling_default %}checked{% endif %}> Live updates</label>
      </div>
      <div class="status-grid">
        <p>Status: <span id="status">{{ 'recording' if status.recording else 'idle' }}</span></p>
        <p>Current file: <span id="current_file">{{ status.current_file or 'n/a' }}</span></p>
        <p>Started at: <span id="started">{{ status.started or 'n/a' }}</span></p>
        <p>Elapsed: <span id="elapsed">00:00:00 (0.00 MB)</span></p>
        <p>Frames recorded: <span id="frames_recorded">{{ status.frames_recorded or 0 }}</span></p>
        <p>Data rate: <span id="data_rate">0 MB/s</span></p>
        <p>LiDAR connection: <span id="lidar_status">unknown</span></p>
        <p>LiDAR stream: <span id="stream_status">
          {% if status.recording %}
            {% if status.lidar_streaming %}streaming{% else %}no data{% endif %}
          {% else %}
            {% if status.lidar_detected %}idle{% else %}n/a{% endif %}
          {% endif %}
        </span>
          <progress id="stream_progress" max="1" value="{{ 1 if status.lidar_streaming else 0 }}"></progress>
        </p>
      </div>
      <div id="actions">
        <button id="start_btn" onclick="startRec()">Start</button>
        <button id="stop_btn" onclick="stopRec()">Stop</button>
      </div>
      <section>
        <h2>Previous recordings</h2>
        <ul id="recordings">
          {% for r in recordings %}
            <li>
              {{ r.folder }} {% if r.started %}(started {{ r.started }}, {% endif %}
              stopped {{ r.stopped }}, frames {{ r.frames }})
            </li>
          {% endfor %}
        </ul>
      </section>
    </main>
    <script>
      const pollingToggle = document.getElementById('polling_toggle');
      let pollingEnabled = pollingToggle.checked;
      pollingToggle.addEventListener('change', (e) => {
        pollingEnabled = e.target.checked;
        if(pollingEnabled){
          updateStatusAndRecordings();
        }
      });

      async function startRec(){
        try{
          const res = await fetch('/start',{method:'POST'});
          const data = await res.json();
          showMessage(res.ok, data.status);
        }catch(err){
          showMessage(false, 'failed to contact server');
        }
        await updateStatusAndRecordings();
      }
      async function stopRec(){
        try{
          const res = await fetch('/stop',{method:'POST'});
          const data = await res.json();
          showMessage(res.ok, data.status);
        }catch(err){
          showMessage(false, 'failed to contact server');
        }
        await updateStatusAndRecordings();
      }

      function showMessage(success, message){
        const msg = document.getElementById('messages');
        const icon = success ? '✅' : '❌';
        msg.innerHTML = `<span aria-hidden="true">${icon}</span> ${message}`;
        msg.setAttribute('aria-label', message);
        msg.style.color = success ? 'green' : 'red';
      }

      function setIndicator(id, text, ok){
        const el = document.getElementById(id);
        el.textContent = text;
        el.className = ok ? 'ok' : 'bad';
      }

      function formatDuration(seconds){
        const h = Math.floor(seconds/3600).toString().padStart(2, '0');
        const m = Math.floor((seconds % 3600)/60).toString().padStart(2, '0');
        const s = (seconds % 60).toString().padStart(2, '0');
        return `${h}:${m}:${s}`;
      }

      function formatSize(bytes){
        if(bytes >= 1024*1024*1024){
          return (bytes/(1024*1024*1024)).toFixed(2)+" GB";
        }
        return (bytes/(1024*1024)).toFixed(2)+" MB";
      }

      async function updateStatusAndRecordings(){
        try{
          const statusRes = await fetch('/status');
          if(statusRes.ok){
            const statusData = await statusRes.json();
            document.getElementById('status').textContent = statusData.recording ? 'recording' : 'idle';
            document.getElementById('current_file').textContent = statusData.current_file || 'n/a';
            document.getElementById('started').textContent = statusData.started || 'n/a';
            document.getElementById('frames_recorded').textContent = statusData.frames_recorded || 0;
            const startBtn = document.getElementById('start_btn');
            const stopBtn = document.getElementById('stop_btn');
            startBtn.disabled = statusData.recording;
            stopBtn.disabled = !statusData.recording;
            setIndicator('eth0_ip', statusData.eth0_ip || 'eth0 ?', !!statusData.eth0_ip);
            setIndicator('lidar_ip', statusData.lidar_ip || 'lidar ?', statusData.lidar_detected);
            setIndicator('livox_driver', 'driver', statusData.livox_driver);
            setIndicator('save_laz', 'save_laz', statusData.save_laz);
            setIndicator('laszip', 'laszip', statusData.laszip);
            setIndicator('flash', 'storage', statusData.storage_present);
            const freeEl = document.getElementById('free_space');
            if(statusData.free_space != null){
              freeEl.textContent = formatSize(statusData.free_space) + ' free';
              const gb = statusData.free_space/(1024*1024*1024);
              freeEl.className = gb < 1 ? 'warn' : 'ok';
            }else{
              freeEl.textContent = '?';
              freeEl.className = 'bad';
            }
            const lidarEl = document.getElementById('lidar_status');
            if(statusData.lidar_detected){
              lidarEl.innerHTML = '<span aria-hidden="true">✅</span> connected';
              lidarEl.setAttribute('aria-label', 'connected');
              lidarEl.style.color = 'green';
            }else{
              lidarEl.innerHTML = '<span aria-hidden="true">❌</span> disconnected';
              lidarEl.setAttribute('aria-label', 'disconnected');
              lidarEl.style.color = 'red';
            }
            const streamEl = document.getElementById('stream_status');
            const streamProg = document.getElementById('stream_progress');
            if(statusData.recording){
              if(statusData.lidar_streaming){
                streamEl.innerHTML = '<span aria-hidden="true">✅</span> streaming';
                streamEl.setAttribute('aria-label', 'streaming');
                streamEl.style.color = 'green';
                streamProg.value = 1;
              }else{
                streamEl.innerHTML = '<span aria-hidden="true">❌</span> no data';
                streamEl.setAttribute('aria-label', 'no data');
                streamEl.style.color = 'red';
                streamProg.value = 0;
              }
            }else{
              if(statusData.lidar_detected){
                streamEl.textContent = 'idle';
                streamEl.setAttribute('aria-label', 'idle');
                streamEl.style.color = 'black';
                streamProg.value = 0;
              }else{
                streamEl.innerHTML = '<span aria-hidden="true">❌</span> n/a';
                streamEl.setAttribute('aria-label', 'not available');
                streamEl.style.color = 'red';
                streamProg.value = 0;
              }
            }
            if(!statusData.storage_present){
              showMessage(false, 'No external USB drive detected');
            }else if(!statusData.lidar_detected){
              showMessage(false, 'No LiDAR detected');
            }else if(statusData.recording && !statusData.lidar_streaming){
              showMessage(false, 'No LiDAR data received');
            }else{
              const msg = document.getElementById('messages');
              if(['No external USB drive detected','No LiDAR detected','No LiDAR data received'].includes(msg.getAttribute('aria-label'))){
                msg.textContent = '';
                msg.removeAttribute('aria-label');
              }
            }
            const sizeStr = formatSize(statusData.current_size || 0);
            if(statusData.recording && statusData.started){
              const elapsedMs = Date.now() - Date.parse(statusData.started);
              const elapsedStr = formatDuration(Math.floor(elapsedMs/1000));
              const elapsedSec = elapsedMs/1000;
              document.getElementById('elapsed').textContent = `${elapsedStr} (${sizeStr})`;
              let rateStr = '0 MB/s';
              if(elapsedSec > 0 && statusData.current_size){
                rateStr = `${formatSize(statusData.current_size/elapsedSec)}/s`;
              }
              document.getElementById('data_rate').textContent = rateStr;
            }else{
              document.getElementById('elapsed').textContent = `00:00:00 (${sizeStr})`;
              document.getElementById('data_rate').textContent = '0 MB/s';
            }
          }else{
            showMessage(false, 'failed to fetch status');
          }
        }catch(err){
          showMessage(false, 'failed to fetch status');
        }

        try{
          const recordingsRes = await fetch('/recordings');
          if(recordingsRes.ok){
            const recordingsData = await recordingsRes.json();
            const list = document.getElementById('recordings');
            list.innerHTML = '';
            recordingsData.recordings.forEach(r => {
              const li = document.createElement('li');
              const started = r.started ? `started ${r.started}, ` : '';
              li.textContent = `${r.folder} (${started}stopped ${r.stopped}, frames ${r.frames})`;
              list.appendChild(li);
            });
          }else{
            showMessage(false, 'failed to fetch recordings');
          }
        }catch(err){
          showMessage(false, 'failed to fetch recordings');
        }
      }

      // Periodically refresh status to provide live updates
      // Poll less frequently to reduce server load; a push-based approach
      // (e.g. WebSockets) could be used in the future.
      setInterval(() => { if(pollingEnabled) updateStatusAndRecordings(); }, 5000);
      if(pollingEnabled) updateStatusAndRecordings();
    </script>
  </body>
</html>
