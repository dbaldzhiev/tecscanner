<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Remote Mandeye Controller for HDMapping</title>
    <style>
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
    </style>
  </head>
  <body>
    <h1>Remote Mandeye Controller for HDMapping</h1>
    <div id="messages" role="status" aria-live="polite"></div>
    <p>Status: <span id="status">{{ 'recording' if status.recording else 'idle' }}</span></p>
    <p>Current file: <span id="current_file">{{ status.current_file or 'n/a' }}</span></p>
    <p>Started at: <span id="started">{{ status.started or 'n/a' }}</span></p>
    <p>Elapsed: <span id="elapsed">00:00:00 (0.00 MB)</span></p>
    <p>LiDAR connection: <span id="lidar_status">unknown</span></p>
    <p>LiDAR stream: <span id="stream_status">n/a</span></p>
    <button id="start_btn" onclick="startRec()">Start</button>
    <button id="stop_btn" onclick="stopRec()">Stop</button>
    <h2>Previous recordings</h2>
    <ul id="recordings">
        {% for r in recordings %}
          <li>{{ r.file }} {% if r.started %}(started {{ r.started }}, {% endif %}stopped {{ r.stopped }})</li>
        {% endfor %}
    </ul>
    <script>
      async function startRec(){
        try{
          const res = await fetch('/start',{method:'POST'});
          const data = await res.json();
          showMessage(res.ok, data.status);
        }catch(err){
          showMessage(false, 'failed to contact server');
        }
        await updateStatusAndRecordings();
      }
      async function stopRec(){
        try{
          const res = await fetch('/stop',{method:'POST'});
          const data = await res.json();
          showMessage(res.ok, data.status);
        }catch(err){
          showMessage(false, 'failed to contact server');
        }
        await updateStatusAndRecordings();
      }

      function showMessage(success, message){
        const msg = document.getElementById('messages');
        msg.textContent = message;
        msg.style.color = success ? 'green' : 'red';
      }

      function formatDuration(seconds){
        const h = Math.floor(seconds/3600).toString().padStart(2, '0');
        const m = Math.floor((seconds % 3600)/60).toString().padStart(2, '0');
        const s = (seconds % 60).toString().padStart(2, '0');
        return `${h}:${m}:${s}`;
      }

      function formatSize(bytes){
        if(bytes >= 1024*1024*1024){
          return (bytes/(1024*1024*1024)).toFixed(2)+" GB";
        }
        return (bytes/(1024*1024)).toFixed(2)+" MB";
      }

      async function updateStatusAndRecordings(){
        try{
          const statusRes = await fetch('/status');
          if(statusRes.ok){
            const statusData = await statusRes.json();
            document.getElementById('status').textContent = statusData.recording ? 'recording' : 'idle';
            document.getElementById('current_file').textContent = statusData.current_file || 'n/a';
            document.getElementById('started').textContent = statusData.started || 'n/a';
            const startBtn = document.getElementById('start_btn');
            const stopBtn = document.getElementById('stop_btn');
            startBtn.disabled = statusData.recording;
            stopBtn.disabled = !statusData.recording;
            const lidarEl = document.getElementById('lidar_status');
            lidarEl.textContent = statusData.lidar_detected ? 'connected' : 'disconnected';
            lidarEl.style.color = statusData.lidar_detected ? 'green' : 'red';
            const streamEl = document.getElementById('stream_status');
            if(statusData.recording){
              streamEl.textContent = statusData.lidar_streaming ? 'streaming' : 'no data';
              streamEl.style.color = statusData.lidar_streaming ? 'green' : 'red';
            }else{
              streamEl.textContent = statusData.lidar_detected ? 'idle' : 'n/a';
              streamEl.style.color = statusData.lidar_detected ? 'black' : 'red';
            }
            if(!statusData.storage_present){
              showMessage(false, 'No external USB drive detected');
            }else if(!statusData.lidar_detected){
              showMessage(false, 'No LiDAR detected');
            }else if(statusData.recording && !statusData.lidar_streaming){
              showMessage(false, 'No LiDAR data received');
            }else{
              const msg = document.getElementById('messages');
              if(['No external USB drive detected','No LiDAR detected','No LiDAR data received'].includes(msg.textContent)){
                msg.textContent = '';
              }
            }
            const sizeStr = formatSize(statusData.current_size || 0);
            if(statusData.recording && statusData.started){
              const elapsedMs = Date.now() - Date.parse(statusData.started);
              const elapsedStr = formatDuration(Math.floor(elapsedMs/1000));
              document.getElementById('elapsed').textContent = `${elapsedStr} (${sizeStr})`;
            }else{
              document.getElementById('elapsed').textContent = `00:00:00 (${sizeStr})`;
            }
          }else{
            showMessage(false, 'failed to fetch status');
          }
        }catch(err){
          showMessage(false, 'failed to fetch status');
        }

        try{
          const recordingsRes = await fetch('/recordings');
          if(recordingsRes.ok){
            const recordingsData = await recordingsRes.json();
            const list = document.getElementById('recordings');
            list.innerHTML = '';
            recordingsData.recordings.forEach(r => {
              const li = document.createElement('li');
              const started = r.started ? `started ${r.started}, ` : '';
              li.textContent = `${r.file} (${started}stopped ${r.stopped})`;
              list.appendChild(li);
            });
          }else{
            showMessage(false, 'failed to fetch recordings');
          }
        }catch(err){
          showMessage(false, 'failed to fetch recordings');
        }
      }

      // Periodically refresh status to provide live updates
      // Poll less frequently to reduce server load; a push-based approach
      // (e.g. WebSockets) could be used in the future.
      setInterval(updateStatusAndRecordings, 5000);
      updateStatusAndRecordings();
    </script>
  </body>
</html>
