<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Remote Mandeye Controller for HDMapping</title>
    <style>
      :root {
        --primary: #007bff;
        --danger: #dc3545;
        --bg: #f4f4f4;
      }
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        background: var(--bg);
      }
      .container {
        max-width: 480px;
        margin: 0 auto;
        padding: 1rem;
      }
      h1 {
        text-align: center;
        font-size: 1.5rem;
        margin-bottom: 1rem;
      }
      #messages {
        text-align: center;
        margin-bottom: 1rem;
        min-height: 1.2rem;
      }
      .status-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: .5rem;
        margin-bottom: 1rem;
      }
      .status-grid p {
        margin: 0;
        padding: .5rem;
        background: #fff;
        border-radius: 4px;
        font-size: 0.9rem;
      }
      #actions {
        display: flex;
        justify-content: space-between;
        margin-bottom: 1rem;
      }
      button {
        flex: 1;
        padding: 0.75rem;
        font-size: 1rem;
        border: none;
        border-radius: 4px;
        color: #fff;
      }
      button + button {
        margin-left: .5rem;
      }
      #start_btn {
        background: var(--primary);
      }
      #stop_btn {
        background: var(--danger);
      }
      button:disabled {
        background: #ccc;
        color: #666;
        cursor: not-allowed;
        opacity: .6;
      }
      ul {
        padding-left: 1rem;
      }
      @media (min-width: 600px) {
        .container { max-width: 700px; }
        .status-grid { grid-template-columns: repeat(2, 1fr); }
        button { flex: none; padding: 0.75rem 1.5rem; }
      }
    </style>
  </head>
  <body>
    <main class="container">
      <h1>Remote Mandeye Controller for HDMapping</h1>
      <div id="messages" role="status" aria-live="polite"></div>
      <div class="status-grid">
        <p>Status: <span id="status">{{ 'recording' if status.recording else 'idle' }}</span></p>
        <p>Current file: <span id="current_file">{{ status.current_file or 'n/a' }}</span></p>
        <p>Started at: <span id="started">{{ status.started or 'n/a' }}</span></p>
        <p>Elapsed: <span id="elapsed">00:00:00 (0.00 MB)</span></p>
        <p>LiDAR connection: <span id="lidar_status">unknown</span></p>
        <p>LiDAR stream: <span id="stream_status">n/a</span></p>
      </div>
      <div id="actions">
        <button id="start_btn" onclick="startRec()">Start</button>
        <button id="stop_btn" onclick="stopRec()">Stop</button>
      </div>
      <section>
        <h2>Previous recordings</h2>
        <ul id="recordings">
          {% for r in recordings %}
            <li>{{ r.folder }} {% if r.started %}(started {{ r.started }}, {% endif %}stopped {{ r.stopped }}, frames {{ r.frames }})</li>
          {% endfor %}
        </ul>
      </section>
    </main>
    <script>
      async function startRec(){
        try{
          const res = await fetch('/start',{method:'POST'});
          const data = await res.json();
          showMessage(res.ok, data.status);
        }catch(err){
          showMessage(false, 'failed to contact server');
        }
        await updateStatusAndRecordings();
      }
      async function stopRec(){
        try{
          const res = await fetch('/stop',{method:'POST'});
          const data = await res.json();
          showMessage(res.ok, data.status);
        }catch(err){
          showMessage(false, 'failed to contact server');
        }
        await updateStatusAndRecordings();
      }

      function showMessage(success, message){
        const msg = document.getElementById('messages');
        const icon = success ? '✅' : '❌';
        msg.innerHTML = `<span aria-hidden="true">${icon}</span> ${message}`;
        msg.setAttribute('aria-label', message);
        msg.style.color = success ? 'green' : 'red';
      }

      function formatDuration(seconds){
        const h = Math.floor(seconds/3600).toString().padStart(2, '0');
        const m = Math.floor((seconds % 3600)/60).toString().padStart(2, '0');
        const s = (seconds % 60).toString().padStart(2, '0');
        return `${h}:${m}:${s}`;
      }

      function formatSize(bytes){
        if(bytes >= 1024*1024*1024){
          return (bytes/(1024*1024*1024)).toFixed(2)+" GB";
        }
        return (bytes/(1024*1024)).toFixed(2)+" MB";
      }

      async function updateStatusAndRecordings(){
        try{
          const statusRes = await fetch('/status');
          if(statusRes.ok){
            const statusData = await statusRes.json();
            document.getElementById('status').textContent = statusData.recording ? 'recording' : 'idle';
            document.getElementById('current_file').textContent = statusData.current_file || 'n/a';
            document.getElementById('started').textContent = statusData.started || 'n/a';
            const startBtn = document.getElementById('start_btn');
            const stopBtn = document.getElementById('stop_btn');
            startBtn.disabled = statusData.recording;
            stopBtn.disabled = !statusData.recording;
            const lidarEl = document.getElementById('lidar_status');
            if(statusData.lidar_detected){
              lidarEl.innerHTML = '<span aria-hidden="true">✅</span> connected';
              lidarEl.setAttribute('aria-label', 'connected');
              lidarEl.style.color = 'green';
            }else{
              lidarEl.innerHTML = '<span aria-hidden="true">❌</span> disconnected';
              lidarEl.setAttribute('aria-label', 'disconnected');
              lidarEl.style.color = 'red';
            }
            const streamEl = document.getElementById('stream_status');
            if(statusData.recording){
              if(statusData.lidar_streaming){
                streamEl.innerHTML = '<span aria-hidden="true">✅</span> streaming';
                streamEl.setAttribute('aria-label', 'streaming');
                streamEl.style.color = 'green';
              }else{
                streamEl.innerHTML = '<span aria-hidden="true">❌</span> no data';
                streamEl.setAttribute('aria-label', 'no data');
                streamEl.style.color = 'red';
              }
            }else{
              if(statusData.lidar_detected){
                streamEl.textContent = 'idle';
                streamEl.setAttribute('aria-label', 'idle');
                streamEl.style.color = 'black';
              }else{
                streamEl.innerHTML = '<span aria-hidden="true">❌</span> n/a';
                streamEl.setAttribute('aria-label', 'not available');
                streamEl.style.color = 'red';
              }
            }
            if(!statusData.storage_present){
              showMessage(false, 'No external USB drive detected');
            }else if(!statusData.lidar_detected){
              showMessage(false, 'No LiDAR detected');
            }else if(statusData.recording && !statusData.lidar_streaming){
              showMessage(false, 'No LiDAR data received');
            }else{
              const msg = document.getElementById('messages');
              if(['No external USB drive detected','No LiDAR detected','No LiDAR data received'].includes(msg.getAttribute('aria-label'))){
                msg.textContent = '';
                msg.removeAttribute('aria-label');
              }
            }
            const sizeStr = formatSize(statusData.current_size || 0);
            if(statusData.recording && statusData.started){
              const elapsedMs = Date.now() - Date.parse(statusData.started);
              const elapsedStr = formatDuration(Math.floor(elapsedMs/1000));
              document.getElementById('elapsed').textContent = `${elapsedStr} (${sizeStr})`;
            }else{
              document.getElementById('elapsed').textContent = `00:00:00 (${sizeStr})`;
            }
          }else{
            showMessage(false, 'failed to fetch status');
          }
        }catch(err){
          showMessage(false, 'failed to fetch status');
        }

        try{
          const recordingsRes = await fetch('/recordings');
          if(recordingsRes.ok){
            const recordingsData = await recordingsRes.json();
            const list = document.getElementById('recordings');
            list.innerHTML = '';
            recordingsData.recordings.forEach(r => {
              const li = document.createElement('li');
              const started = r.started ? `started ${r.started}, ` : '';
              li.textContent = `${r.folder} (${started}stopped ${r.stopped}, frames ${r.frames})`;
              list.appendChild(li);
            });
          }else{
            showMessage(false, 'failed to fetch recordings');
          }
        }catch(err){
          showMessage(false, 'failed to fetch recordings');
        }
      }

      // Periodically refresh status to provide live updates
      // Poll less frequently to reduce server load; a push-based approach
      // (e.g. WebSockets) could be used in the future.
      setInterval(updateStatusAndRecordings, 5000);
      updateStatusAndRecordings();
    </script>
  </body>
</html>
